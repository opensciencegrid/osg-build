#!/usr/bin/python
"""A package promotion script for OSG"""
# TODO: Implement --wiki
# TODO: Do not attempt to promote a build if the build is already in the destination
# TODO This code needs rewriting to use less globals and be less brittle.
#      mostly because the above two todo items, while they look trivial, and
#      should be trivial, aren't.
#      The mix of what's in the 'Promoter' class and what isn't is also
#      inconsistent.



import glob
import re
import os
import shutil
import subprocess
import sys
import time
import urllib

from osgbuild import kojiinter
from osgbuild import utils
from osgbuild.utils import printf, print_table
from optparse import OptionParser


kojihelper = None
options = None
dvers = []

class YourTagsAreMessedUp(Exception):
    pass

VALID_DVERS = ["el5", "el6"]
STATIC_VALID_ROUTES = {
    "hcc": ["hcc-%s-testing", "hcc-%s-release"],
    "old-upcoming": ["%s-osg-upcoming-development", "%s-osg-upcoming-testing"],
    "old-testing": ["%s-osg-development", "%s-osg-testing"],
    "old-contrib": ["%s-osg-testing", "%s-osg-contrib"],
    # XXX These are for testing and should be removed once we switch over to the new koji tags
    "new-upcoming": ["osg-upcoming-%s-development", "osg-upcoming-%s-testing"],
    "new-testing": ["osg-3.1-%s-development", "osg-3.1-%s-testing"],
    "new-contrib": ["osg-3.1-%s-testing", "osg-3.1-%s-contrib"],
   }

def any(iterable): # Don't warn about redefining this. pylint: disable=W0622
    """True if any member of 'iterable' is true, False otherwise"""
    for element in iterable:
        if element:
            return True
    return False

def parse_cmdline_args(argv):
    """Return a tuple of (options, positional args)"""
    parser = OptionParser("""
    %prog -r|--route ROUTE [options] <packages or builds>
""")
    parser.add_option("-r", "--route", default="testing", type='choice', choices=VALID_ROUTES.keys(),
                      help="The promotion route to use. Valid routes are: " + ", ".join(VALID_ROUTES.keys()))
    parser.add_option("-n", "--dry-run", action="store_true", default=False,
                      help="Do not promote, just show what would be done")
    parser.add_option("--el5-only", action="store_false", dest='el6', default=True,
                      help="Promote only el5 packages.")
    parser.add_option("--el6-only", action="store_false", dest='el5', default=True,
                      help="Promote only el6 packages.")
    parser.add_option("--ignore-rejects", dest="ignore_rejects", action="store_true", default=False,
                      help="Ignore rejections due to version mismatch between dvers or missing package for one dver")
    of_choices = ['old', 'prerelnote', 'relnote', 'none']
    parser.add_option("--output-format", "--of", default='old', type='choice', choices=of_choices,
                      help="Valid output formats are: " + ", ".join(of_choices))
    parser.add_option("--no-date", "--nodate", default=False, action="store_true",
                      help="Do not add the date to the wiki code")
    parser.add_option("--regen", default=False, action="store_true",
                      help="Regenerate repo(s) afterward")
    parser.add_option("-w", "--wiki", "--twiki", default=False, action="store_true",
                      help="Do not promote, only generate wiki code for the arguments. (Unimplemented)")
    # ^ TODO Implement this
    parser.add_option("-y", "--assume-yes", action="store_true", default=False,
                      help="Do not prompt before promotion")

    options, args = parser.parse_args(argv[1:])

    if not options.el5 and not options.el6:
        parser.error("Can't specify both --el5-only and --el6-only")

    # optparse doesn't do 'append_const' in python 2.4 so simulate it
    options.dvers = []
    if options.el5: options.dvers.append('el5')
    if options.el6: options.dvers.append('el6')

    if options.route:
        # User is allowed to specify the shortest unambiguous prefix of a route
        matching_routes = [x for x in VALID_ROUTES.keys() if x.startswith(options.route)]
        if len(matching_routes) > 1:
            parser.error("Ambiguous route. Matching routes are: " + ", ".join(matching_routes))
        elif not matching_routes:
            parser.error("Invalid route. Valid routes are: " + ", ".join(VALID_ROUTES.keys()))
        else:
            options.route = matching_routes[0]
    else:
        parser.error("Missing required parameter '--route'")

    if options.wiki:
        options.dry_run = True

    return (options, args)


def split_nvr(build):
    """Split an NVR into a [Name, Version, Release] list"""
    match = re.match(r"(?P<name>.+)-(?P<version>[^-]+)-(?P<release>[^-]+)$", build)
    if match:
        return [match.group('name'), match.group('version'), match.group('release')]
    else:
        return []


def get_osg_releases():
    """Returns the available OSG releases (e.g. 3.1, 3.2, etc.)"""
    tags = kojihelper.get_tags()
    releases = set()
    for tag in tags:
        osg_pattern = re.compile(r"^osg-(\d+\.\d+)-(el\d+)-release$")
        match_obj = osg_pattern.search(tag)
        if match_obj:
            releases.add(match_obj.group(1))
    return releases


def get_testing_tags_osgvers_dvers(tags):
    osg_testing_pattern = re.compile(r"^osg-(\d+\.\d+)-(el\d+)-testing$")
    testing_tags_osgvers_dvers = []
    for tag in tags:
        match = osg_testing_pattern.search(tag)
        if match:
            testing_tags_osgvers_dvers.append((tag,) + match.group(1, 2))
    return testing_tags_osgvers_dvers

def get_valid_routes():
    """Return available promotion routes as a dict of (from_tag, to_tag) pairs"""
    valid_routes = {}
    valid_routes += STATIC_VALID_ROUTES
    valid_routes += get_valid_osg_routes()


def validate_route(route, dver):
    """Ensure both sides of a route exist for the given dver.
    Route is a pair of printf-style strings of a from_tag and a to_tag with
    %s where the dver should go.
    """
    from_tag = route[0] % dver
    to_tag = route[1] % dver
    tags = kojihelper.get_tags()
    return (from_tag in tags and to_tag in tags)


def get_valid_osg_routes():
    valid_osg_routes = {}
    osgvers = set()
    tags = kojihelper.get_tags()
    for testing_tag, osgver, dver in get_testing_tags_osgvers_dvers(tags):
        osgvers.add(osgver)
        devel_tag_hint = "osg-%s-%%s-development" % (osgver)
        contrib_tag_hint = "osg-%s-%%s-contrib" % (osgver)
        testing_tag_hint = "osg-%s-%%s-testing" % (osgver)

        potential_routes = {osgver + "-testing": (devel_tag_hint, testing_tag_hint),
                            osgver + "-contrib": (testing_tag_hint, contrib_tag_hint)}

        for route_name, route in potential_routes.iteritems():
            if validate_route(route, dver):
                valid_osg_routes[route_name] = route
            else:
                raise YourTagsAreMessedUp("Can't make %s route, some tags are missing" % route_name)

    # Get highest osgver
    # TODO misses the case where there is a 3.2-testing but only a 3.1-contrib
    highest_osgver = sorted(list(osgvers), cmp=(lambda a,b: cmp(a.split("."), b.split("."))))
    highest_testing = '%s-testing' % highest_osgver
    highest_contrib = '%s-contrib' % highest_osgver
    if valid_osg_routes.has_key(highest_testing):
        valid_osg_routes['testing'] = valid_osg_routes[highest_testing]
    if valid_osg_routes.has_key(highest_contrib):
        valid_osg_routes['contrib'] = valid_osg_routes[highest_contrib]

    return valid_osg_routes


def get_valid_dvers_for_route(route):
    """Return the available dvers for the given route ('route' is an index into valid_routes)"""
    tags = kojihelper.get_tags()
    tag_pattern = re.compile(re.sub(r'%s', r'(el\d+)', route[0]))
    available_tags = [x for x in tags if tag_pattern.match(x)]
    dver_pattern = re.compile(r'(el\d+)')
    available_dvers = []
    for tag in available_tags:
        m = dver_pattern.search(tag)
        if m:
            available_dvers.append(m.group(1))
    return available_dvers


# TODO This should not raise an exception
def get_tag(pattern, dver=None):
    """Return the name of a koji tag matching 'pattern' for 'dver'.
    For example, get_tag('development', 'el5') returns 'el5-osg-development'
    If 'dver' is None, then the dver is assumed to be part of 'pattern'.
    Raise an Exception if no matching tag is found.

    """
    def get_first_tag(match, terms):
        try:
            return kojihelper.search_names(terms, 'tag', match)[0]
        except IndexError:
            return None
    if dver is None:
        tag = (get_first_tag('exact', pattern) or get_first_tag('regex', re.escape(pattern) + ".*"))
    else:
        split_pattern = pattern.split("-", 1)
        tag = (# New-style tags
               get_first_tag('exact', '%s-%s-%s' % (split_pattern[0], dver, split_pattern[-1])) or # like hcc-el6-testing
               get_first_tag('exact', "%s-%s" % (pattern, dver)) or # like uscms-el6
               get_first_tag('regex', "%s-%s-%s.*" % (re.escape(split_pattern[0]), dver, re.escape(split_pattern[-1]))) or # like osg-el6-release-3.1.3
               # old-style tags
               get_first_tag('exact', "%s-%s" % (dver, pattern)) or # like el5-osg
               get_first_tag('exact', "%s-osg-%s" % (dver, pattern)) or # like el5-osg-upcoming
               get_first_tag('regex', "%s-(osg-)?%s.*" % (dver, re.escape(pattern))) # like el5-osg-release-3.1.3
              )
    if not tag:
        raise Exception("Can't find tag %s or variations of it in koji" % pattern)
    return tag


def split_dver(build):
    """Split out the dver from the NVR of 'build'.
    For example, split_dver("foobar-1-1.osg.el5") returns
    ("foobar-1-1.osg", "el5")
    Return the empty string for the dver if it's not in the NVR.

    """
    pattern = re.compile(r".(el\d)$")
    nvr_no_dver = pattern.sub("", build)
    dver = pattern.search(build)
    return (nvr_no_dver, dver and dver.group(1) or "")



def get_builds(tag_base, pkg_or_build):
    """Get a dict of builds keyed by dver for pkg_or_build.
    If pkg_or_build is a package, then it gets the latest version of the
    package in tag_base + dver.
    If pkg_or_build is a build, then it uses that specific version.

    If options.ignore_rejects is False, then it can reject packages if
    either of the following apply:
    * pkg_or_build is a build and a build with that NVR is missing from
      at least one dver. (For example, pkg_or_build is foobar-1-1.osg.el5,
      and foobar-1-1.osg.el5 exists but foobar-1-1.osg.el6 doesn't).
    * pkg_or_build is a package and the NVRs of the latest version of that
      package are different across NVRs. (For example, pkg_or_build is
      foobar, el5 has foobar-1-1.osg.el5, and el6 has foobar-1-2.osg.el6).
    In either of those cases, neither the el5 or the el6 builds should be
    promoted.

    In case of a rejection (or no matching packages found at all), an
    empty dict is returned.
    """
    builds = {}
    # Find each build for all dvers matching pkg_or_build
    for dver in dvers:
        tag = get_tag(tag_base, dver)

        pkg_or_build_no_dver, _ = split_dver(pkg_or_build)
        # Case 1: pkg_or_build is a build, in which case take off its dver
        # and put the current dver on, then find a build for that.
        build1 = kojihelper.get_build_in_tag(tag, "%s.%s" % (pkg_or_build_no_dver, dver))
        # Case 2: pkg_or_build is a package, in which case putting a dver
        # on doesn't help--just find the latest build in the tag.
        build2 = kojihelper.get_build_in_tag(tag, pkg_or_build_no_dver)

        build = build1 or build2
        if not build:
            printf("Warning: There is no build matching %s for dver %s.", pkg_or_build, dver, end='')
            if not options.ignore_rejects:
                print " Rejected package."
                return {}
            else:
                print ""
                continue
        builds[dver] = build

    if len(builds) == 0:
        return {}
    # find builds where the VERSION-RELEASEs (without dver) are distinct
    # between the dvers we are running the script for, and reject them.
    vrs = ['-'.join(split_nvr(builds[x])[1:]) for x in builds]
    vrs_no_dver = [split_dver(x)[0] for x in vrs]
    if len(set(vrs_no_dver)) > 1:
        printf("Warning: The versions of the builds matching %s are distinct across dvers.", pkg_or_build, end='')
        if not options.ignore_rejects:
            print " Rejected package."
            return {}
        else:
            print ""
    return builds


class Promoter(object):
    def __init__(self, route):
        self.tag_pkg_args = {}
        self.rejects = []
        self.from_tag_base, self.to_tag_base = VALID_ROUTES[route]


    def add_promotion(self, pkg_or_build):
        """See if 'pkg_or_build' can be promoted, add the build to
        self.tag_pkg_args for each tag it should be added to.

        """
        builds = get_builds(self.from_tag_base, pkg_or_build)
        if not builds and not options.ignore_rejects:
            self.rejects.append(pkg_or_build)
        else:
            for dver in builds:
                to_tag = get_tag(self.to_tag_base, dver)

                build = builds[dver]
                self.tag_pkg_args.setdefault(to_tag, [])
                self.tag_pkg_args[to_tag].append(build)


    def do_promotions(self):
        """Tag all builds selected to be tagged in self.tag_pkg_args.
        self.tag_pkg_args is a list of (tag, [builds]) pairs.

        If options.dry_run is True, no actual tagging happens.  If
        options.regen is True, then each repository that gets modified will be
        regenerated after all tagging is done.

        Will not attempt to tag builds already in the destination tag.

        Return a list of builds successfully promoted.

        """
        printf("--- Tagging builds")
        tasks = dict()
        for tag, builds in self.tag_pkg_args.iteritems():
            for build in builds:
                try:
                    # Make sure the build isn't already in tag
                    if build in kojihelper.get_tagged_builds(tag):
                        printf("Skipping %s, already in %s", build, tag)
                        continue
                except KeyError:
                    pass

                build_no_dver, dver = split_dver(build)
                # Launch the builds
                if not options.dry_run:
                    task_id = kojihelper.tag_build(tag, build)
                    tasks[task_id] = (build_no_dver, dver, build)
                else:
                    printf("tagBuild('%s', '%s')", tag, build)

        if not options.dry_run:
            promoted_builds = watch_builds(tasks)

        if options.regen:
            print "--- Regenerating repos"
            kojihelper.regen_repos(tags_to_regen=self.tag_pkg_args.keys())

        return promoted_builds


def watch_builds(tasks):
    kojihelper.watch_tasks(list(tasks.keys()))

    promoted_builds = {}
    for task_id in tasks:
        build_no_dver, dver, build = tasks[task_id]
        if kojihelper.get_task_state(task_id) == 'CLOSED':
            promoted_builds.setdefault(build_no_dver, dict())
            promoted_builds[build_no_dver][dver] = build
        else:
            printf("* Error promoting build %s", build)



def write_twiki(builds):
    out = sys.stdout
    first = True
    if options.output_format == 'relnote':
        # Release note format
        #    * build-1-2.osg.el5
        #    * build-1-2.osg.el6
        for dver in dvers:
            for build_no_dver in sorted(builds):
                build = builds[build_no_dver][dver]
                out.write("   * [[%s][%s]]\n" % (kojihelper.get_build_uri(build), build))
    elif options.output_format == 'old' or options.output_format == 'prerelnote':
        # Old (current) format, used in PreReleaseNotes
        # | DATE | build-1-2.osg (el5+el6) |
        for build_no_dver in sorted(builds):
            if first and not options.no_date:
                out.write("| %s |" % time.strftime("%Y-%m-%d"))
                first = False
            else:
                out.write("||")
            out.write(" %(build_no_dver)s " % locals())
            build_links = []
            for dver in sorted(builds[build_no_dver]):
                build = builds[build_no_dver][dver]
                build_links.append("[[%s][%s]]" % (kojihelper.get_build_uri(build), dver))
            out.write("(" + "+".join(build_links) + ")")
            out.write(" |\n")
    elif options.output_format == 'none':
        pass
    else:
        # Sanity check, but optparse should have caught this already
        print >> sys.stderr, "Unknown output format!"


class KojiHelper(kojiinter.KojiLibInter):
    tags_cache = []
    tagged_builds_cache = {}
    tagged_packages_cache = {}

    def __init__(self, do_login):
        "Connect to koji-hub. Authenticate if 'do_login' is True."
        kojiinter.KojiLibInter.__init__(self)
        self.read_config_file()
        self.init_koji_session(login=do_login)

    def get_build_in_tag(self, tag, pkg_or_build):
        """Return the build matching 'pkg_or_build' in 'tag'.
        If pkg_or_build is not in the tag, returns None. Otherwise:
        If pkg_or_build is a package, returns the latest build for that
        package. If pkg_or_build is a build, it is returned unchanged.

        """
        if pkg_or_build in self.get_tagged_packages(tag):
            return self.get_latest_build(pkg_or_build, tag)
        elif pkg_or_build in self.get_tagged_builds(tag):
            return pkg_or_build
        else:
            return None

    def get_build_uri(self, build):
        """Return a URI to the kojiweb page of the build with the given NVR"""
        buildinfo = self.kojisession.getBuild(build)
        return ("https://koji-hub.batlab.org/koji/buildinfo?buildID=%d" % int(buildinfo['id']))

    def get_latest_build(self, package, tag):
        """Return the NVR of the latest build of a package in a tag, or None"""
        data = self.kojisession.listTagged(tag, latest=True, package=package)
        if not data:
            return None
        else:
            try:
                return data[0]['nvr']
            except KeyError:
                return None

    def get_tagged_builds(self, tag):
        """Return a list of NVRs of all builds in a tag"""
        if not KojiHelper.tagged_builds_cache.has_key(tag):
            data = self.kojisession.listTagged(tag)
            KojiHelper.tagged_builds_cache[tag] = [x['nvr'] for x in data]
        return KojiHelper.tagged_builds_cache[tag]

    def get_tagged_packages(self, tag):
        """Return a list of names of all builds in a tag"""
        if not KojiHelper.tagged_packages_cache.has_key(tag):
            KojiHelper.tagged_packages_cache[tag] = [split_nvr(x)[0] for x in self.get_tagged_builds(tag)]
        return KojiHelper.tagged_packages_cache[tag]

    def get_tags(self):
        """Return a list of all tag names"""
        if not KojiHelper.tags_cache:
            data = self.kojisession.listTags(None, None)
            KojiHelper.tags_cache = [x['name'] for x in data]
        return KojiHelper.tags_cache

    def get_task_state(self, task_id):
        """Return the symbolic state of the task (e.g. OPEN, CLOSED, etc.) as a string"""
        return self.TASK_STATES[self.kojisession.getTaskInfo(task_id)['state']]

    def regen_repos(self, tags_to_regen):
        """Regenerate the repos corresponding to the given tags.
        'tags_to_regen' is a list of strings.
        Waits for completion.

        """
        for tag in tags_to_regen:
            self.watch_tasks([self.regen_repo(tag)])


def main(argv=None):
    global options
    global dvers
    global kojihelper

    if argv is None:
        argv = sys.argv

    options, pkgs_or_builds = parse_cmdline_args(argv)

    dvers = options.dvers
    route = options.route

    kojihelper = KojiHelper(do_login=not options.dry_run)

    printf("Promoting from %s to %s for dvers: %s", VALID_ROUTES[route][0], VALID_ROUTES[route][1], ", ".join(dvers))
    printf("Examining the following packages/builds:\n%s", "\n".join(["'" + x + "'" for x in pkgs_or_builds]))

    promoter = Promoter(route)
    for x in pkgs_or_builds:
        promoter.add_promotion(x)

    if promoter.rejects:
        print "Rejected package or builds:\n" + "\n".join(promoter.rejects)
        print "Rejects will not be promoted! Rerun with --ignore-rejects to promote them anyway."

    print "Promotion plan:"
    if any(promoter.tag_pkg_args.values()):
        print_table(promoter.tag_pkg_args)
    else:
        printf("Nothing will be promoted!")
        return 1

    question = "Proceed with promoting the builds?"
    try:
        proceed = (options.assume_yes or not sys.stdin.isatty() or utils.ask_yn(question))
    except KeyboardInterrupt:
        printf("Canceled.")
        return 3

    if proceed:
        promoted_builds = promoter.do_promotions()
        if options.output_format != 'none':
            printf("\nTwiki code for this set of promotions:\n")
            write_twiki(promoted_builds)
    else:
        printf("Not proceeding.")
        return 1

    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv))

