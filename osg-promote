#!/usr/bin/python
"""A package promotion script for OSG"""
# TODO: Implement --wiki
# TODO: Do not attempt to promote a build if the build is already in the destination
# TODO This code needs rewriting to use less globals and be less brittle.
#      mostly because the above two todo items, while they look trivial, and
#      should be trivial, aren't.
#      The mix of what's in the 'Promoter' class and what isn't is also
#      inconsistent.



import glob
import re
import os
import shutil
import subprocess
import sys
import time
import urllib

from osgbuild import kojiinter
from osgbuild import utils
from osgbuild.utils import printf, print_table
from optparse import OptionParser


kojihelper = None
options = None
dvers = []

class YourTagsAreMessedUp(Exception):
    pass

STATIC_VALID_ROUTES = {
    "hcc": ["hcc-%s-testing", "hcc-%s-release"],
    "old-upcoming": ["%s-osg-upcoming-development", "%s-osg-upcoming-testing"],
    "old-testing": ["%s-osg-development", "%s-osg-testing"],
    "old-contrib": ["%s-osg-testing", "%s-osg-contrib"],
    "new-upcoming": ["osg-upcoming-%s-development", "osg-upcoming-%s-testing"],
    # XXX v These are for testing and should be removed once we switch over to the new koji tags
    "new-testing": ["osg-3.1-%s-development", "osg-3.1-%s-testing"],
    "new-contrib": ["osg-3.1-%s-testing", "osg-3.1-%s-contrib"],
   }

def any(iterable): # Don't warn about redefining this. pylint: disable=W0622
    """True if any member of 'iterable' is true, False otherwise"""
    for element in iterable:
        if element:
            return True
    return False

def parse_cmdline_args(valid_routes, argv):
    """Return a tuple of (options, positional args)"""
    parser = OptionParser("""
    %prog -r|--route ROUTE [options] <packages or builds>
""")
    parser.add_option("-r", "--route", default="testing", type='choice', choices=valid_routes.keys(),
                      help="The promotion route to use. Valid routes are: " + ", ".join(valid_routes.keys()))
    parser.add_option("-n", "--dry-run", action="store_true", default=False,
                      help="Do not promote, just show what would be done")
    parser.add_option("--el5-only", action="store_false", dest='el6', default=True,
                      help="Promote only el5 packages.")
    parser.add_option("--el6-only", action="store_false", dest='el5', default=True,
                      help="Promote only el6 packages.")
    parser.add_option("--ignore-rejects", dest="ignore_rejects", action="store_true", default=False,
                      help="Ignore rejections due to version mismatch between dvers or missing package for one dver")
    of_choices = ['old', 'prerelnote', 'relnote', 'none']
    parser.add_option("--output-format", "--of", default='old', type='choice', choices=of_choices,
                      help="Valid output formats are: " + ", ".join(of_choices))
    parser.add_option("--no-date", "--nodate", default=False, action="store_true",
                      help="Do not add the date to the wiki code")
    parser.add_option("--regen", default=False, action="store_true",
                      help="Regenerate repo(s) afterward")
    parser.add_option("-w", "--wiki", "--twiki", default=False, action="store_true",
                      help="Do not promote, only generate wiki code for the arguments. (Unimplemented)")
    # ^ TODO Implement this
    parser.add_option("-y", "--assume-yes", action="store_true", default=False,
                      help="Do not prompt before promotion")

    options, args = parser.parse_args(argv[1:])

    if not options.el5 and not options.el6:
        parser.error("Can't specify both --el5-only and --el6-only")

    # optparse doesn't do 'append_const' in python 2.4 so simulate it
    options.dvers = []
    if options.el5: options.dvers.append('el5')
    if options.el6: options.dvers.append('el6')

    if options.route:
        # User is allowed to specify the shortest unambiguous prefix of a route
        matching_routes = [x for x in valid_routes.keys() if x.startswith(options.route)]
        if len(matching_routes) > 1:
            parser.error("Ambiguous route. Matching routes are: " + ", ".join(matching_routes))
        elif not matching_routes:
            parser.error("Invalid route. Valid routes are: " + ", ".join(valid_routes.keys()))
        else:
            options.route = matching_routes[0]
    else:
        parser.error("Missing required parameter '--route'")

    if options.wiki:
        options.dry_run = True

    return (options, args)


def split_nvr(build):
    """Split an NVR into a [Name, Version, Release] list"""
    match = re.match(r"(?P<name>.+)-(?P<version>[^-]+)-(?P<release>[^-]+)$", build)
    if match:
        return [match.group('name'), match.group('version'), match.group('release')]
    else:
        return []


class RouteDiscovery(object):
    osg_testing_pattern = re.compile(r"^osg-(\d+\.\d+)-(el\d+)-testing$")

    def __init__(self, tags):
        self.tags = tags
        self.routes = {}

    def get_routes(self):
        if not self.routes:
            self.routes.update(STATIC_VALID_ROUTES)
            self.routes.update(self.get_valid_osg_routes())

            self.dvers_for_routes = {}
            for route_name, route in self.routes.iteritems():
                dvers = self.get_dvers_for_route(route)
                if not dvers:
                    raise YourTagsAreMessedUp("Route %s has no valid dvers" % route_name)
                else:
                    self.dvers_for_routes[route_name] = dvers
        return self.routes

    def get_highest_osgver(self):
        def cmp_version(a, b):
            return cmp(a.split('.'), b.split('.'))

        osgvers = list(self.get_osgvers())
        if osgvers:
            return sorted(osgvers, cmp=cmp_version)[-1]
        else:
            return None

    def get_osgvers(self):
        """Returns the available OSG versions (e.g. 3.1, 3.2, etc.)"""
        osgvers = set()
        for tag in self.tags:
            match_obj = self.osg_testing_pattern.search(tag)
            if match_obj:
                osgvers.add(match_obj.group(1))
        return osgvers

    def get_testing_tags_osgvers_dvers(self):
        testing_tags_osgvers_dvers = []
        for tag in self.tags:
            match = self.osg_testing_pattern.search(tag)
            if match:
                testing_tags_osgvers_dvers.append((tag,) + match.group(1, 2))
        return testing_tags_osgvers_dvers

    def get_dvers_for_route(self, route):
        """ TODO """
        tag_pattern = re.compile(re.sub(r'%s', r'(el\d+)', route[0]))
        available_tags = [x for x in self.tags if tag_pattern.match(x)]
        dver_pattern = re.compile(r'(el\d+)')
        available_dvers = []
        for tag in available_tags:
            match = dver_pattern.search(tag)
            if match:
                available_dvers.append(match.group(1))
        return available_dvers

    def get_dvers_for_route_by_name(self, route_name):
        route = self.routes[route_name]
        return self.get_dvers_for_route(route)

    def get_valid_osg_routes(self):
        valid_osg_routes = {}
        valid_osg_routes.update(self.get_valid_versioned_osg_routes())
        valid_osg_routes.update(self.get_osg_route_aliases(valid_osg_routes))

        return valid_osg_routes

    def get_valid_versioned_osg_routes(self):
        valid_versioned_osg_routes = {}
        for testing_tag, osgver, dver in self.get_testing_tags_osgvers_dvers():
            devel_tag_hint = "osg-%s-%%s-development" % (osgver)
            contrib_tag_hint = "osg-%s-%%s-contrib" % (osgver)
            testing_tag_hint = "osg-%s-%%s-testing" % (osgver)

            potential_routes = {osgver + "-testing": (devel_tag_hint, testing_tag_hint),
                                osgver + "-contrib": (testing_tag_hint, contrib_tag_hint)}

            for route_name, route in potential_routes.iteritems():
                self.validate_route_for_dver(route, dver)
                valid_versioned_osg_routes[route_name] = route

        return valid_versioned_osg_routes

    def get_osg_route_aliases(self, valid_osg_routes):
        # TODO misses the case where there is a 3.2-testing but only a 3.1-contrib
        osg_route_aliases = {}
        highest_osgver = self.get_highest_osgver()
        if not highest_osgver or not valid_osg_routes:
            osg_route_aliases['testing'] = STATIC_VALID_ROUTES['old-testing']
            osg_route_aliases['upcoming'] = STATIC_VALID_ROUTES['old-upcoming']
            osg_route_aliases['contrib'] = STATIC_VALID_ROUTES['old-contrib']
        else:
            for route_name in ['testing', 'contrib']:
                highest_route_name = '%s-%s' % (highest_osgver, route_name)
                if valid_osg_routes.has_key(highest_route_name):
                    osg_route_aliases[route_name] = valid_osg_routes[highest_route_name]
            osg_route_aliases['upcoming'] = STATIC_VALID_ROUTES['new-upcoming']
        return osg_route_aliases

    def validate_route_for_dver(self, route, dver):
        """ TODO """
        errors = []
        for tag_hint in route:
            tag = tag_hint % dver
            if tag not in self.tags:
                errors.append("%s is missing" % tag)
        if errors:
            raise YourTagsAreMessedUp("Error validating route %s: %s" % (route, "; ".join(errors)))

    def validate_route_by_name_for_dver(self, route_name, dver):
        route = self.routes[route_name]
        return self.validate_route_for_dver(route, dver)


def get_valid_tag_for_dver(tag_hint, dver):
    """ TODO """
    tag = tag_hint % dver
    if not kojihelper.get_first_tag('exact', tag):
        raise YourTagsAreMessedUp("Can't find tag %s in koji" % tag)
    return tag


def split_dver(build):
    """Split out the dver from the NVR of 'build'.
    For example, split_dver("foobar-1-1.osg.el5") returns
    ("foobar-1-1.osg", "el5")
    Return the empty string for the dver if it's not in the NVR.

    """
    pattern = re.compile(r".(el\d+)$")
    nvr_no_dver = pattern.sub("", build)
    dver = pattern.search(build)
    return (nvr_no_dver, dver and dver.group(1) or "")

def trim_dver(build):
    return split_dver(build)[0]


def get_builds(tag_base, pkg_or_build):
    """Get a dict of builds keyed by dver for pkg_or_build.
    If pkg_or_build is a package, then it gets the latest version of the
    package in tag_base + dver.
    If pkg_or_build is a build, then it uses that specific version.

    If options.ignore_rejects is False, then it can reject packages if
    either of the following apply:
    * pkg_or_build is a build and a build with that NVR is missing from
      at least one dver. (For example, pkg_or_build is foobar-1-1.osg.el5,
      and foobar-1-1.osg.el5 exists but foobar-1-1.osg.el6 doesn't).
    * pkg_or_build is a package and the NVRs of the latest version of that
      package are different across NVRs. (For example, pkg_or_build is
      foobar, el5 has foobar-1-1.osg.el5, and el6 has foobar-1-2.osg.el6).
    In either of those cases, neither the el5 or the el6 builds should be
    promoted.

    In case of a rejection (or no matching packages found at all), an
    empty dict is returned.
    """
    builds = {}
    # Find each build for all dvers matching pkg_or_build
    for dver in dvers:
        tag = get_valid_tag_for_dver(tag_base, dver)

        pkg_or_build_no_dver = trim_dver(pkg_or_build)
        # Case 1: pkg_or_build is a build, in which case take off its dver
        # and put the current dver on, then find a build for that.
        build1 = kojihelper.get_build_in_tag(tag, "%s.%s" % (pkg_or_build_no_dver, dver))
        # Case 2: pkg_or_build is a package, in which case putting a dver
        # on doesn't help--just find the latest build in the tag.
        build2 = kojihelper.get_build_in_tag(tag, pkg_or_build_no_dver)

        build = build1 or build2
        if not build:
            printf("Warning: There is no build matching %s for dver %s.", pkg_or_build, dver, end='')
            if not options.ignore_rejects:
                print " Rejected package."
                return {}
            else:
                print ""
                continue
        builds[dver] = build

    if len(builds) == 0:
        return {}
    # find builds where the VERSION-RELEASEs (without dver) are distinct
    # between the dvers we are running the script for, and reject them.
    vrs = ['-'.join(split_nvr(builds[x])[1:]) for x in builds]
    vrs_no_dver = [trim_dver(x) for x in vrs]
    if len(set(vrs_no_dver)) > 1:
        printf("Warning: The versions of the builds matching %s are distinct across dvers.", pkg_or_build, end='')
        if not options.ignore_rejects:
            print " Rejected package."
            return {}
        else:
            print ""
    return builds


class Promoter(object):
    def __init__(self, route):
        self.tag_pkg_args = {}
        self.rejects = []
        self.from_tag_base, self.to_tag_base = route


    def add_promotion(self, pkg_or_build):
        """See if 'pkg_or_build' can be promoted, add the build to
        self.tag_pkg_args for each tag it should be added to.

        """
        builds = get_builds(self.from_tag_base, pkg_or_build)
        if not builds and not options.ignore_rejects:
            self.rejects.append(pkg_or_build)
        else:
            for dver in builds:
                to_tag = get_valid_tag_for_dver(self.to_tag_base, dver)

                build = builds[dver]
                self.tag_pkg_args.setdefault(to_tag, [])
                self.tag_pkg_args[to_tag].append(build)


    def do_promotions(self):
        """Tag all builds selected to be tagged in self.tag_pkg_args.
        self.tag_pkg_args is a list of (tag, [builds]) pairs.

        If options.dry_run is True, no actual tagging happens.  If
        options.regen is True, then each repository that gets modified will be
        regenerated after all tagging is done.

        Will not attempt to tag builds already in the destination tag.

        Return a list of builds successfully promoted.

        """
        printf("--- Tagging builds")
        tasks = dict()
        for tag, builds in self.tag_pkg_args.iteritems():
            for build in builds:
                try:
                    # Make sure the build isn't already in tag
                    if build in kojihelper.get_tagged_builds(tag):
                        printf("Skipping %s, already in %s", build, tag)
                        continue
                except KeyError:
                    pass

                build_no_dver, dver = split_dver(build)
                # Launch the builds
                if not options.dry_run:
                    task_id = kojihelper.tag_build(tag, build)
                    tasks[task_id] = (build_no_dver, dver, build)
                else:
                    printf("tagBuild('%s', '%s')", tag, build)

        if not options.dry_run:
            promoted_builds = watch_builds(tasks)

        if options.regen:
            print "--- Regenerating repos"
            kojihelper.regen_repos(tags_to_regen=self.tag_pkg_args.keys())

        return promoted_builds


def watch_builds(tasks):
    kojihelper.watch_tasks(list(tasks.keys()))

    promoted_builds = {}
    for task_id in tasks:
        build_no_dver, dver, build = tasks[task_id]
        if kojihelper.get_task_state(task_id) == 'CLOSED':
            promoted_builds.setdefault(build_no_dver, dict())
            promoted_builds[build_no_dver][dver] = build
        else:
            printf("* Error promoting build %s", build)



def write_twiki(builds):
    out = sys.stdout
    first = True
    if options.output_format == 'relnote':
        # Release note format
        #    * build-1-2.osg.el5
        #    * build-1-2.osg.el6
        for dver in dvers:
            for build_no_dver in sorted(builds):
                build = builds[build_no_dver][dver]
                out.write("   * [[%s][%s]]\n" % (kojihelper.get_build_uri(build), build))
    elif options.output_format == 'old' or options.output_format == 'prerelnote':
        # Old (current) format, used in PreReleaseNotes
        # | DATE | build-1-2.osg (el5+el6) |
        for build_no_dver in sorted(builds):
            if first and not options.no_date:
                out.write("| %s |" % time.strftime("%Y-%m-%d"))
                first = False
            else:
                out.write("||")
            out.write(" %(build_no_dver)s " % locals())
            build_links = []
            for dver in sorted(builds[build_no_dver]):
                build = builds[build_no_dver][dver]
                build_links.append("[[%s][%s]]" % (kojihelper.get_build_uri(build), dver))
            out.write("(" + "+".join(build_links) + ")")
            out.write(" |\n")
    elif options.output_format == 'none':
        pass
    else:
        # Sanity check, but optparse should have caught this already
        print >> sys.stderr, "Unknown output format!"


class KojiHelper(kojiinter.KojiLibInter):
    tags_cache = []
    tagged_builds_cache = {}
    tagged_packages_cache = {}

    def __init__(self, do_login):
        "Connect to koji-hub. Authenticate if 'do_login' is True."
        super(KojiHelper, self).__init__()
        self.read_config_file()
        self.init_koji_session(login=do_login)

    def get_build_in_tag(self, tag, pkg_or_build):
        """Return the build matching 'pkg_or_build' in 'tag'.
        If pkg_or_build is not in the tag, returns None. Otherwise:
        If pkg_or_build is a package, returns the latest build for that
        package. If pkg_or_build is a build, it is returned unchanged.

        """
        if pkg_or_build in self.get_tagged_packages(tag):
            return self.get_latest_build(pkg_or_build, tag)
        elif pkg_or_build in self.get_tagged_builds(tag):
            return pkg_or_build
        else:
            return None

    def get_build_uri(self, build):
        """Return a URI to the kojiweb page of the build with the given NVR"""
        buildinfo = self.kojisession.getBuild(build)
        return ("https://koji-hub.batlab.org/koji/buildinfo?buildID=%d" % int(buildinfo['id']))

    def get_first_tag(self, match, terms):
        try:
            return self.search_names(terms, 'tag', match)[0]
        except IndexError:
            return None

    def get_latest_build(self, package, tag):
        """Return the NVR of the latest build of a package in a tag, or None"""
        data = self.kojisession.listTagged(tag, latest=True, package=package)
        if not data:
            return None
        else:
            try:
                return data[0]['nvr']
            except KeyError:
                return None

    def get_tagged_builds(self, tag):
        """Return a list of NVRs of all builds in a tag"""
        if not KojiHelper.tagged_builds_cache.has_key(tag):
            data = self.kojisession.listTagged(tag)
            KojiHelper.tagged_builds_cache[tag] = [x['nvr'] for x in data]
        return KojiHelper.tagged_builds_cache[tag]

    def get_tagged_packages(self, tag):
        """Return a list of names of all builds in a tag"""
        if not KojiHelper.tagged_packages_cache.has_key(tag):
            KojiHelper.tagged_packages_cache[tag] = [split_nvr(x)[0] for x in self.get_tagged_builds(tag)]
        return KojiHelper.tagged_packages_cache[tag]

    def get_tags(self):
        """Return a list of all tag names"""
        if not KojiHelper.tags_cache:
            data = self.kojisession.listTags(None, None)
            KojiHelper.tags_cache = [x['name'] for x in data]
        return KojiHelper.tags_cache

    def get_task_state(self, task_id):
        """Return the symbolic state of the task (e.g. OPEN, CLOSED, etc.) as a string"""
        return self.TASK_STATES[self.kojisession.getTaskInfo(task_id)['state']]

    def regen_repos(self, tags_to_regen):
        """Regenerate the repos corresponding to the given tags.
        'tags_to_regen' is a list of strings.
        Waits for completion.

        """
        for tag in tags_to_regen:
            self.watch_tasks([self.regen_repo(tag)])


def main(argv=None):
    global options
    global dvers
    global kojihelper

    if argv is None:
        argv = sys.argv

    kojihelper = KojiHelper(False)

    route_discovery = RouteDiscovery(kojihelper.get_tags())
    valid_routes = route_discovery.get_routes()

    options, pkgs_or_builds = parse_cmdline_args(valid_routes, argv)

    dvers = options.dvers
    route = options.route

    dvers_for_route = route_discovery.get_dvers_for_route_by_name(route)
    for dver in dvers:
        if dver not in dvers_for_route:
            raise Exception("%s not available for route %s" % (dver, route))

    if not options.dry_run:
        kojihelper.login_to_koji()

    printf("Promoting from %s to %s for dvers: %s", valid_routes[route][0], valid_routes[route][1], ", ".join(dvers))
    printf("Examining the following packages/builds:\n%s", "\n".join(["'" + x + "'" for x in pkgs_or_builds]))

    promoter = Promoter(valid_routes[route])
    for x in pkgs_or_builds:
        promoter.add_promotion(x)

    if promoter.rejects:
        print "Rejected package or builds:\n" + "\n".join(promoter.rejects)
        print "Rejects will not be promoted! Rerun with --ignore-rejects to promote them anyway."

    print "Promotion plan:"
    if any(promoter.tag_pkg_args.values()):
        print_table(promoter.tag_pkg_args)
    else:
        printf("Nothing will be promoted!")
        return 1

    question = "Proceed with promoting the builds?"
    try:
        proceed = (options.assume_yes or not sys.stdin.isatty() or utils.ask_yn(question))
    except KeyboardInterrupt:
        printf("Canceled.")
        return 3

    if proceed:
        promoted_builds = promoter.do_promotions()
        if options.output_format != 'none':
            printf("\nTwiki code for this set of promotions:\n")
            write_twiki(promoted_builds)
    else:
        printf("Not proceeding.")
        return 1

    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv))

